{"version":3,"sources":["../../webpack/universalModuleDefinition","../../webpack/bootstrap","services/Utilities.js","services/PhysicalKeyboard.js","services/KeyboardLayout.js","components/Keyboard.js","index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Utilities","getOptions","getCaretPosition","dispatch","this","bindMethods","myClass","instance","getOwnPropertyNames","myMethod","button","buttonTypeClass","includes","buttonWithoutBraces","replace","buttonNormalized","display","mergeDisplay","assign","getDefaultDiplay","input","caretPos","moveCaret","options","output","length","removeAt","addStringAt","tabCharOnTab","newLineOnEnter","Number","isInteger","minus","newCaretPos","updateCaretPosAction","caretPosition","debug","console","log","keyboardDOMClass","source","string","position","slice","join","isMaxLengthReached","updateCaretPos","emojiMatchedReg","substring","match","substr","inputObj","updatedInput","maxLength","currentInput","inputName","condition","maxLengthReached","Boolean","navigator","maxTouchPoints","PointerEvent","toLowerCase","trim","split","reduce","word","toUpperCase","PhysicalKeyboard","event","buttonPressed","getSimpleKeyboardLayoutKey","buttonDOM","getButtonElement","style","backgroundColor","physicalKeyboardHighlightBgColor","color","physicalKeyboardHighlightTextColor","removeAttribute","code","KeyboardLayout","default","shift","SimpleKeyboard","initCallback","keyboardDOMQuery","utilities","keyboardDOM","document","querySelector","layoutName","theme","preventMouseDownDefault","keyboardPluginClasses","buttonElements","camelCase","allKeyboardInstances","currentInstanceName","keyboardInstanceNames","keys","isFirstKeyboardInstance","physicalKeyboard","warn","Error","render","loadModules","onKeyPress","getUpdatedInput","inputPattern","inputPatternIsValid","handleMaxLength","syncInstanceInputs","onChange","onChangeAll","e","preventDefault","stopMouseDownPropagation","stopPropagation","isMouseHold","holdInteractionTimeout","clearTimeout","holdTimeout","disableButtonHold","setTimeout","handleButtonHold","onKeyReleased","handleButtonClicked","replaceInput","onSetOptions","innerHTML","className","callback","forEach","buttons","classNameItem","buttonTheme","classNameFound","map","class","buttonThemeArray","push","Array","isArray","index","filteredButtonArray","filter","item","splice","buttonArr","inputVal","inputPatternRaw","RegExp","didInputMatch","test","addEventListener","handleKeyUp","handleKeyDown","handleMouseUp","handleTouchEnd","caretEventHandler","physicalKeyboardHighlight","handleHighlightKeyUp","handleHighlightKeyDown","targetTagName","target","tagName","disableCaretPositioning","selectionStart","removeEventListener","clear","buttonClasses","themeObj","themeObjClasses","buttonAttributes","attrObj","attribute","processAutoTouchEvents","disableContextualWindow","oncontextmenu","classList","contains","autoUseTouchEvents","useTouchEvents","setEventListeners","onInit","isTouchDevice","onTouchDeviceDetected","beforeFirstRender","pointerEventsSupported","useMouseEvents","beforeRender","onRender","onModulesLoaded","Module","constructor","classStr","init","prop","rowDOM","rowIndex","containerStartIndexes","containerEndIndexes","rowDOMArray","from","children","removedElements","startIndex","arrIndex","endIndex","updated_startIndex","updated_endIndex","containerDOM","createElement","containerUID","setAttribute","containedElements","element","appendChild","initialized","layoutClass","layout","getDefaultLayout","useTouchEventsClass","disableRowButtonContainers","row","rIndex","rowArray","bIndex","buttonHasContainerStart","buttonHasContainerEnd","fctBtnClass","getButtonClass","buttonDisplayName","getButtonDisplayName","buttonType","useButtonTag","add","getButtonThemeClasses","setDOMButtonAttributes","ontouchstart","handleButtonMouseDown","ontouchend","handleButtonMouseUp","ontouchcancel","onclick","onmousedown","onmouseup","onpointerdown","onpointerup","onpointercancel","buttonUID","buttonSpanDOM","parseRowDOMContainers","handleKeyboardContainerMouseDown"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SimpleKeyboard\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SimpleKeyboard\"] = factory();\n\telse\n\t\troot[\"SimpleKeyboard\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * Utility Service\n */\nclass Utilities {\n  /**\n   * Creates an instance of the Utility service\n   */\n  constructor({ getOptions, getCaretPosition, dispatch }) {\n    this.getOptions = getOptions;\n    this.getCaretPosition = getCaretPosition;\n    this.dispatch = dispatch;\n\n    /**\n     * Bindings\n     */\n    Utilities.bindMethods(Utilities, this);\n  }\n\n  /**\n   * Adds default classes to a given button\n   *\n   * @param  {string} button The button's layout name\n   * @return {string} The classes to be added to the button\n   */\n  getButtonClass(button) {\n    let buttonTypeClass =\n      button.includes(\"{\") && button.includes(\"}\") && button !== \"{//}\"\n        ? \"functionBtn\"\n        : \"standardBtn\";\n    let buttonWithoutBraces = button.replace(\"{\", \"\").replace(\"}\", \"\");\n    let buttonNormalized = \"\";\n\n    if (buttonTypeClass !== \"standardBtn\")\n      buttonNormalized = ` hg-button-${buttonWithoutBraces}`;\n\n    return `hg-${buttonTypeClass}${buttonNormalized}`;\n  }\n\n  /**\n   * Default button display labels\n   */\n  getDefaultDiplay() {\n    return {\n      \"{bksp}\": \"backspace\",\n      \"{backspace}\": \"backspace\",\n      \"{enter}\": \"< enter\",\n      \"{shift}\": \"shift\",\n      \"{shiftleft}\": \"shift\",\n      \"{shiftright}\": \"shift\",\n      \"{alt}\": \"alt\",\n      \"{s}\": \"shift\",\n      \"{tab}\": \"tab\",\n      \"{lock}\": \"caps\",\n      \"{capslock}\": \"caps\",\n      \"{accept}\": \"Submit\",\n      \"{space}\": \" \",\n      \"{//}\": \" \",\n      \"{esc}\": \"esc\",\n      \"{escape}\": \"esc\",\n      \"{f1}\": \"f1\",\n      \"{f2}\": \"f2\",\n      \"{f3}\": \"f3\",\n      \"{f4}\": \"f4\",\n      \"{f5}\": \"f5\",\n      \"{f6}\": \"f6\",\n      \"{f7}\": \"f7\",\n      \"{f8}\": \"f8\",\n      \"{f9}\": \"f9\",\n      \"{f10}\": \"f10\",\n      \"{f11}\": \"f11\",\n      \"{f12}\": \"f12\",\n      \"{numpaddivide}\": \"/\",\n      \"{numlock}\": \"lock\",\n      \"{arrowup}\": \"↑\",\n      \"{arrowleft}\": \"←\",\n      \"{arrowdown}\": \"↓\",\n      \"{arrowright}\": \"→\",\n      \"{prtscr}\": \"print\",\n      \"{scrolllock}\": \"scroll\",\n      \"{pause}\": \"pause\",\n      \"{insert}\": \"ins\",\n      \"{home}\": \"home\",\n      \"{pageup}\": \"up\",\n      \"{delete}\": \"del\",\n      \"{end}\": \"end\",\n      \"{pagedown}\": \"down\",\n      \"{numpadmultiply}\": \"*\",\n      \"{numpadsubtract}\": \"-\",\n      \"{numpadadd}\": \"+\",\n      \"{numpadenter}\": \"enter\",\n      \"{period}\": \".\",\n      \"{numpaddecimal}\": \".\",\n      \"{numpad0}\": \"0\",\n      \"{numpad1}\": \"1\",\n      \"{numpad2}\": \"2\",\n      \"{numpad3}\": \"3\",\n      \"{numpad4}\": \"4\",\n      \"{numpad5}\": \"5\",\n      \"{numpad6}\": \"6\",\n      \"{numpad7}\": \"7\",\n      \"{numpad8}\": \"8\",\n      \"{numpad9}\": \"9\"\n    };\n  }\n  /**\n   * Returns the display (label) name for a given button\n   *\n   * @param  {string} button The button's layout name\n   * @param  {object} display The provided display option\n   * @param  {boolean} mergeDisplay Whether the provided param value should be merged with the default one.\n   */\n  getButtonDisplayName(button, display, mergeDisplay) {\n    if (mergeDisplay) {\n      display = Object.assign({}, this.getDefaultDiplay(), display);\n    } else {\n      display = display || this.getDefaultDiplay();\n    }\n\n    return display[button] || button;\n  }\n\n  /**\n   * Returns the updated input resulting from clicking a given button\n   *\n   * @param  {string} button The button's layout name\n   * @param  {string} input The input string\n   * @param  {number} caretPos The cursor's current position\n   * @param  {boolean} moveCaret Whether to update simple-keyboard's cursor\n   */\n  getUpdatedInput(button, input, caretPos, moveCaret) {\n    let options = this.getOptions();\n    let output = input;\n\n    if (\n      (button === \"{bksp}\" || button === \"{backspace}\") &&\n      output.length > 0\n    ) {\n      output = this.removeAt(output, caretPos, moveCaret);\n    } else if (button === \"{space}\")\n      output = this.addStringAt(output, \" \", caretPos, moveCaret);\n    else if (\n      button === \"{tab}\" &&\n      !(\n        typeof options.tabCharOnTab === \"boolean\" &&\n        options.tabCharOnTab === false\n      )\n    ) {\n      output = this.addStringAt(output, \"\\t\", caretPos, moveCaret);\n    } else if (\n      (button === \"{enter}\" || button === \"{numpadenter}\") &&\n      options.newLineOnEnter\n    )\n      output = this.addStringAt(output, \"\\n\", caretPos, moveCaret);\n    else if (\n      button.includes(\"numpad\") &&\n      Number.isInteger(Number(button[button.length - 2]))\n    ) {\n      output = this.addStringAt(\n        output,\n        button[button.length - 2],\n        caretPos,\n        moveCaret\n      );\n    } else if (button === \"{numpaddivide}\")\n      output = this.addStringAt(output, \"/\", caretPos, moveCaret);\n    else if (button === \"{numpadmultiply}\")\n      output = this.addStringAt(output, \"*\", caretPos, moveCaret);\n    else if (button === \"{numpadsubtract}\")\n      output = this.addStringAt(output, \"-\", caretPos, moveCaret);\n    else if (button === \"{numpadadd}\")\n      output = this.addStringAt(output, \"+\", caretPos, moveCaret);\n    else if (button === \"{numpaddecimal}\")\n      output = this.addStringAt(output, \".\", caretPos, moveCaret);\n    else if (button === \"{\" || button === \"}\")\n      output = this.addStringAt(output, button, caretPos, moveCaret);\n    else if (!button.includes(\"{\") && !button.includes(\"}\"))\n      output = this.addStringAt(output, button, caretPos, moveCaret);\n\n    return output;\n  }\n\n  /**\n   * Moves the cursor position by a given amount\n   *\n   * @param  {number} length Represents by how many characters the input should be moved\n   * @param  {boolean} minus Whether the cursor should be moved to the left or not.\n   */\n  updateCaretPos(length, minus) {\n    let newCaretPos = this.updateCaretPosAction(length, minus);\n\n    this.dispatch(instance => {\n      instance.caretPosition = newCaretPos;\n    });\n  }\n\n  /**\n   * Action method of updateCaretPos\n   *\n   * @param  {number} length Represents by how many characters the input should be moved\n   * @param  {boolean} minus Whether the cursor should be moved to the left or not.\n   */\n  updateCaretPosAction(length, minus) {\n    let options = this.getOptions();\n    let caretPosition = this.getCaretPosition();\n\n    if (minus) {\n      if (caretPosition > 0) caretPosition = caretPosition - length;\n    } else {\n      caretPosition = caretPosition + length;\n    }\n\n    if (options.debug) {\n      console.log(\"Caret at:\", caretPosition, `(${this.keyboardDOMClass})`);\n    }\n\n    return caretPosition;\n  }\n\n  /**\n   * Adds a string to the input at a given position\n   *\n   * @param  {string} source The source input\n   * @param  {string} string The string to add\n   * @param  {number} position The (cursor) position where the string should be added\n   * @param  {boolean} moveCaret Whether to update simple-keyboard's cursor\n   */\n  addStringAt(source, string, position, moveCaret) {\n    let output;\n\n    if (!position && position !== 0) {\n      output = source + string;\n    } else {\n      output = [source.slice(0, position), string, source.slice(position)].join(\n        \"\"\n      );\n\n      /**\n       * Avoid caret position change when maxLength is set\n       */\n      if (!this.isMaxLengthReached()) {\n        if (moveCaret) this.updateCaretPos(string.length);\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * Removes an amount of characters at a given position\n   *\n   * @param  {string} source The source input\n   * @param  {number} position The (cursor) position from where the characters should be removed\n   * @param  {boolean} moveCaret Whether to update simple-keyboard's cursor\n   */\n  removeAt(source, position, moveCaret) {\n    let caretPosition = this.getCaretPosition();\n\n    if (caretPosition === 0) {\n      return source;\n    }\n\n    let output;\n    let prevTwoChars;\n    let emojiMatched;\n    let emojiMatchedReg = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])/g;\n\n    /**\n     * Emojis are made out of two characters, so we must take a custom approach to trim them.\n     * For more info: https://mathiasbynens.be/notes/javascript-unicode\n     */\n    if (position && position >= 0) {\n      prevTwoChars = source.substring(position - 2, position);\n      emojiMatched = prevTwoChars.match(emojiMatchedReg);\n\n      if (emojiMatched) {\n        output = source.substr(0, position - 2) + source.substr(position);\n        if (moveCaret) this.updateCaretPos(2, true);\n      } else {\n        output = source.substr(0, position - 1) + source.substr(position);\n        if (moveCaret) this.updateCaretPos(1, true);\n      }\n    } else {\n      prevTwoChars = source.slice(-2);\n      emojiMatched = prevTwoChars.match(emojiMatchedReg);\n\n      if (emojiMatched) {\n        output = source.slice(0, -2);\n        if (moveCaret) this.updateCaretPos(2, true);\n      } else {\n        output = source.slice(0, -1);\n        if (moveCaret) this.updateCaretPos(1, true);\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Determines whether the maxLength has been reached. This function is called when the maxLength option it set.\n   *\n   * @param  {object} inputObj\n   * @param  {string} updatedInput\n   */\n  handleMaxLength(inputObj, updatedInput) {\n    let options = this.getOptions();\n    let maxLength = options.maxLength;\n    let currentInput = inputObj[options.inputName];\n    let condition = updatedInput.length - 1 >= maxLength;\n\n    if (\n      /**\n       * If pressing this button won't add more characters\n       * We exit out of this limiter function\n       */\n      updatedInput.length <= currentInput.length\n    ) {\n      return false;\n    }\n\n    if (Number.isInteger(maxLength)) {\n      if (options.debug) {\n        console.log(\"maxLength (num) reached:\", condition);\n      }\n\n      if (condition) {\n        /**\n         * @type {boolean} Boolean value that shows whether maxLength has been reached\n         */\n        this.maxLengthReached = true;\n        return true;\n      } else {\n        this.maxLengthReached = false;\n        return false;\n      }\n    }\n\n    if (typeof maxLength === \"object\") {\n      let condition = currentInput.length === maxLength[options.inputName];\n\n      if (options.debug) {\n        console.log(\"maxLength (obj) reached:\", condition);\n      }\n\n      if (condition) {\n        this.maxLengthReached = true;\n        return true;\n      } else {\n        this.maxLengthReached = false;\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Gets the current value of maxLengthReached\n   */\n  isMaxLengthReached() {\n    return Boolean(this.maxLengthReached);\n  }\n\n  /**\n   * Determines whether a touch device is being used\n   */\n  isTouchDevice() {\n    return \"ontouchstart\" in window || navigator.maxTouchPoints;\n  }\n\n  /**\n   * Determines whether pointer events are supported\n   */\n  pointerEventsSupported() {\n    return window.PointerEvent;\n  }\n\n  /**\n   * Bind all methods in a given class\n   */\n\n  static bindMethods(myClass, instance) {\n    // eslint-disable-next-line no-unused-vars\n    for (let myMethod of Object.getOwnPropertyNames(myClass.prototype)) {\n      let excludeMethod =\n        myMethod === \"constructor\" || myMethod === \"bindMethods\";\n      if (!excludeMethod) {\n        instance[myMethod] = instance[myMethod].bind(instance);\n      }\n    }\n  }\n\n  /**\n   * Transforms an arbitrary string to camelCase\n   *\n   * @param  {string} string The string to transform.\n   */\n  camelCase(string) {\n    if (!string) return false;\n\n    return string\n      .toLowerCase()\n      .trim()\n      .split(/[.\\-_\\s]/g)\n      .reduce((string, word) =>\n        word.length ? string + word[0].toUpperCase() + word.slice(1) : string\n      );\n  }\n}\n\nexport default Utilities;\n","import Utilities from \"../services/Utilities\";\n\n/**\n * Physical Keyboard Service\n */\nclass PhysicalKeyboard {\n  /**\n   * Creates an instance of the PhysicalKeyboard service\n   */\n  constructor({ dispatch, getOptions }) {\n    /**\n     * @type {object} A simple-keyboard instance\n     */\n    this.dispatch = dispatch;\n    this.getOptions = getOptions;\n\n    /**\n     * Bindings\n     */\n    Utilities.bindMethods(PhysicalKeyboard, this);\n  }\n\n  handleHighlightKeyDown(event) {\n    let options = this.getOptions();\n    let buttonPressed = this.getSimpleKeyboardLayoutKey(event);\n\n    this.dispatch(instance => {\n      let buttonDOM =\n        instance.getButtonElement(buttonPressed) ||\n        instance.getButtonElement(`{${buttonPressed}}`);\n\n      if (buttonDOM) {\n        buttonDOM.style.backgroundColor =\n          options.physicalKeyboardHighlightBgColor || \"#9ab4d0\";\n        buttonDOM.style.color =\n          options.physicalKeyboardHighlightTextColor || \"white\";\n      }\n    });\n  }\n\n  handleHighlightKeyUp(event) {\n    let buttonPressed = this.getSimpleKeyboardLayoutKey(event);\n\n    this.dispatch(instance => {\n      let buttonDOM =\n        instance.getButtonElement(buttonPressed) ||\n        instance.getButtonElement(`{${buttonPressed}}`);\n\n      if (buttonDOM && buttonDOM.removeAttribute) {\n        buttonDOM.removeAttribute(\"style\");\n      }\n    });\n  }\n\n  /**\n   * Transforms a KeyboardEvent's \"key.code\" string into a simple-keyboard layout format\n   * @param  {object} event The KeyboardEvent\n   */\n  getSimpleKeyboardLayoutKey(event) {\n    let output;\n\n    if (\n      event.code.includes(\"Numpad\") ||\n      event.code.includes(\"Shift\") ||\n      event.code.includes(\"Space\") ||\n      event.code.includes(\"Backspace\") ||\n      event.code.includes(\"Control\") ||\n      event.code.includes(\"Alt\") ||\n      event.code.includes(\"Meta\")\n    ) {\n      output = event.code;\n    } else {\n      output = event.key;\n    }\n\n    /**\n     * If button is not uppercase, casting to lowercase\n     */\n    if (\n      output !== output.toUpperCase() ||\n      (event.code[0] === \"F\" &&\n        Number.isInteger(Number(event.code[1])) &&\n        event.code.length <= 3)\n    ) {\n      output = output.toLowerCase();\n    }\n\n    return output;\n  }\n}\n\nexport default PhysicalKeyboard;\n","/**\n * Keyboard Layout Service\n */\nclass KeyboardLayout {\n  /**\n   * Get default simple-keyboard layout\n   * @return {object} The default layout (US-QWERTY)\n   */\n  static getDefaultLayout() {\n    return {\n      default: [\n        \"` 1 2 3 4 5 6 7 8 9 0 - = {bksp}\",\n        \"{tab} q w e r t y u i o p [ ] \\\\\",\n        \"{lock} a s d f g h j k l ; ' {enter}\",\n        \"{shift} z x c v b n m , . / {shift}\",\n        \".com @ {space}\"\n      ],\n      shift: [\n        \"~ ! @ # $ % ^ & * ( ) _ + {bksp}\",\n        \"{tab} Q W E R T Y U I O P { } |\",\n        '{lock} A S D F G H J K L : \" {enter}',\n        \"{shift} Z X C V B N M < > ? {shift}\",\n        \".com @ {space}\"\n      ]\n    };\n  }\n}\n\nexport default KeyboardLayout;\n","import \"./Keyboard.css\";\n\n// Services\nimport PhysicalKeyboard from \"../services/PhysicalKeyboard\";\nimport KeyboardLayout from \"../services/KeyboardLayout\";\nimport Utilities from \"../services/Utilities\";\n\n/**\n * Root class for simple-keyboard\n * This class:\n * - Parses the options\n * - Renders the rows and buttons\n * - Handles button functionality\n */\nclass SimpleKeyboard {\n  /**\n   * Creates an instance of SimpleKeyboard\n   * @param {Array} params If first parameter is a string, it is considered the container class. The second parameter is then considered the options object. If first parameter is an object, it is considered the options object.\n   */\n  constructor(...params) {\n    let keyboardDOMQuery =\n      typeof params[0] === \"string\" ? params[0] : \".simple-keyboard\";\n    let options = typeof params[0] === \"object\" ? params[0] : params[1];\n\n    if (!options) options = {};\n\n    /**\n     * Initializing Utilities\n     */\n    this.utilities = new Utilities({\n      getOptions: this.getOptions,\n      getCaretPosition: this.getCaretPosition,\n      dispatch: this.dispatch\n    });\n\n    /**\n     * Caret position\n     */\n    this.caretPosition = null;\n\n    /**\n     * Processing options\n     */\n    this.keyboardDOM = document.querySelector(keyboardDOMQuery);\n\n    /**\n     * @type {object}\n     * @property {object} layout Modify the keyboard layout.\n     * @property {string} layoutName Specifies which layout should be used.\n     * @property {object} display Replaces variable buttons (such as {bksp}) with a human-friendly name (e.g.: “backspace”).\n     * @property {boolean} mergeDisplay By default, when you set the display property, you replace the default one. This setting merges them instead.\n     * @property {string} theme A prop to add your own css classes to the keyboard wrapper. You can add multiple classes separated by a space.\n     * @property {Array} buttonTheme A prop to add your own css classes to one or several buttons.\n     * @property {Array} buttonAttributes A prop to add your own attributes to one or several buttons.\n     * @property {boolean} debug Runs a console.log every time a key is pressed. Displays the buttons pressed and the current input.\n     * @property {boolean} newLineOnEnter Specifies whether clicking the “ENTER” button will input a newline (\\n) or not.\n     * @property {boolean} tabCharOnTab Specifies whether clicking the “TAB” button will input a tab character (\\t) or not.\n     * @property {string} inputName Allows you to use a single simple-keyboard instance for several inputs.\n     * @property {number} maxLength Restrains all of simple-keyboard inputs to a certain length. This should be used in addition to the input element’s maxlengthattribute.\n     * @property {object} maxLength Restrains simple-keyboard’s individual inputs to a certain length. This should be used in addition to the input element’s maxlengthattribute.\n     * @property {boolean} syncInstanceInputs When set to true, this option synchronizes the internal input of every simple-keyboard instance.\n     * @property {boolean} physicalKeyboardHighlight Enable highlighting of keys pressed on physical keyboard.\n     * @property {boolean} preventMouseDownDefault Calling preventDefault for the mousedown events keeps the focus on the input.\n     * @property {string} physicalKeyboardHighlightTextColor Define the text color that the physical keyboard highlighted key should have.\n     * @property {string} physicalKeyboardHighlightBgColor Define the background color that the physical keyboard highlighted key should have.\n     * @property {function(button: string):string} onKeyPress Executes the callback function on key press. Returns button layout name (i.e.: “{shift}”).\n     * @property {function(input: string):string} onChange Executes the callback function on input change. Returns the current input’s string.\n     * @property {function} onRender Executes the callback function every time simple-keyboard is rendered (e.g: when you change layouts).\n     * @property {function} onInit Executes the callback function once simple-keyboard is rendered for the first time (on initialization).\n     * @property {function(inputs: object):object} onChangeAll Executes the callback function on input change. Returns the input object with all defined inputs.\n     * @property {boolean} useButtonTag Render buttons as a button element instead of a div element.\n     * @property {boolean} disableCaretPositioning A prop to ensure characters are always be added/removed at the end of the string.\n     * @property {object} inputPattern Restrains input(s) change to the defined regular expression pattern.\n     * @property {boolean} useTouchEvents Instructs simple-keyboard to use touch events instead of click events.\n     * @property {boolean} autoUseTouchEvents Enable useTouchEvents automatically when touch device is detected.\n     * @property {boolean} useMouseEvents Opt out of PointerEvents handling, falling back to the prior mouse event logic.\n     * @property {function} destroy Clears keyboard listeners and DOM elements.\n     * @property {boolean} disableButtonHold Disable button hold action.\n     * @property {function} onKeyReleased Executes the callback function on key release.\n     */\n    this.options = options;\n    this.options.layoutName = this.options.layoutName || \"default\";\n    this.options.theme = this.options.theme || \"hg-theme-default\";\n    this.options.inputName = this.options.inputName || \"default\";\n    this.options.preventMouseDownDefault =\n      this.options.preventMouseDownDefault || false;\n\n    /**\n     * @type {object} Classes identifying loaded plugins\n     */\n    this.keyboardPluginClasses = \"\";\n\n    /**\n     * Bindings\n     */\n    Utilities.bindMethods(SimpleKeyboard, this);\n\n    /**\n     * simple-keyboard uses a non-persistent internal input to keep track of the entered string (the variable `keyboard.input`).\n     * This removes any dependency to input DOM elements. You can type and directly display the value in a div element, for example.\n     * @example\n     * // To get entered input\n     * let input = keyboard.getInput();\n     *\n     * // To clear entered input.\n     * keyboard.clearInput();\n     *\n     * @type {object}\n     * @property {object} default Default SimpleKeyboard internal input.\n     * @property {object} myInputName Example input that can be set through `options.inputName:\"myInputName\"`.\n     */\n    this.input = {};\n    this.input[this.options.inputName] = \"\";\n\n    /**\n     * @type {string} DOM class of the keyboard wrapper, normally \"simple-keyboard\" by default.\n     */\n    this.keyboardDOMClass = keyboardDOMQuery.split(\".\").join(\"\");\n\n    /**\n     * @type {object} Contains the DOM elements of every rendered button, the key being the button's layout name (e.g.: \"{enter}\").\n     */\n    this.buttonElements = {};\n\n    /**\n     * Simple-keyboard Instances\n     * This enables multiple simple-keyboard support with easier management\n     */\n    if (!window[\"SimpleKeyboardInstances\"])\n      window[\"SimpleKeyboardInstances\"] = {};\n\n    window[\"SimpleKeyboardInstances\"][\n      this.utilities.camelCase(this.keyboardDOMClass)\n    ] = this;\n\n    /**\n     * Instance vars\n     */\n    this.allKeyboardInstances = window[\"SimpleKeyboardInstances\"];\n    this.currentInstanceName = this.utilities.camelCase(this.keyboardDOMClass);\n    this.keyboardInstanceNames = Object.keys(window[\"SimpleKeyboardInstances\"]);\n    this.isFirstKeyboardInstance =\n      this.keyboardInstanceNames[0] === this.currentInstanceName;\n\n    /**\n     * Physical Keyboard support\n     */\n    this.physicalKeyboard = new PhysicalKeyboard({\n      dispatch: this.dispatch,\n      getOptions: this.getOptions\n    });\n\n    /**\n     * Rendering keyboard\n     */\n    if (this.keyboardDOM) this.render();\n    else {\n      console.warn(`\"${keyboardDOMQuery}\" was not found in the DOM.`);\n      throw new Error(\"KEYBOARD_DOM_ERROR\");\n    }\n\n    /**\n     * Modules\n     */\n    this.modules = {};\n    this.loadModules();\n  }\n\n  /**\n   * Getters\n   */\n  getOptions = () => this.options;\n  getCaretPosition = () => this.caretPosition;\n\n  /**\n   * Handles clicks made to keyboard buttons\n   * @param  {string} button The button's layout name.\n   */\n  handleButtonClicked(button) {\n    let debug = this.options.debug;\n\n    /**\n     * Ignoring placeholder buttons\n     */\n    if (button === \"{//}\") return false;\n\n    /**\n     * Calling onKeyPress\n     */\n    if (typeof this.options.onKeyPress === \"function\")\n      this.options.onKeyPress(button);\n\n    if (!this.input[this.options.inputName])\n      this.input[this.options.inputName] = \"\";\n\n    let updatedInput = this.utilities.getUpdatedInput(\n      button,\n      this.input[this.options.inputName],\n      this.caretPosition\n    );\n\n    if (\n      // If input will change as a result of this button press\n      this.input[this.options.inputName] !== updatedInput &&\n      // This pertains to the \"inputPattern\" option:\n      // If inputPattern isn't set\n      (!this.options.inputPattern ||\n        // Or, if it is set and if the pattern is valid - we proceed.\n        (this.options.inputPattern && this.inputPatternIsValid(updatedInput)))\n    ) {\n      /**\n       * If maxLength and handleMaxLength yield true, halting\n       */\n      if (\n        this.options.maxLength &&\n        this.utilities.handleMaxLength(this.input, updatedInput)\n      ) {\n        return false;\n      }\n\n      this.input[this.options.inputName] = this.utilities.getUpdatedInput(\n        button,\n        this.input[this.options.inputName],\n        this.caretPosition,\n        true\n      );\n\n      if (debug) console.log(\"Input changed:\", this.input);\n\n      /**\n       * Enforce syncInstanceInputs, if set\n       */\n      if (this.options.syncInstanceInputs) this.syncInstanceInputs();\n\n      /**\n       * Calling onChange\n       */\n      if (typeof this.options.onChange === \"function\")\n        this.options.onChange(this.input[this.options.inputName]);\n\n      /**\n       * Calling onChangeAll\n       */\n      if (typeof this.options.onChangeAll === \"function\")\n        this.options.onChangeAll(this.input);\n    }\n\n    if (debug) {\n      console.log(\"Key pressed:\", button);\n    }\n  }\n\n  /**\n   * Handles button mousedown\n   */\n  /* istanbul ignore next */\n  handleButtonMouseDown(button, e) {\n    /**\n     * Handle event options\n     */\n    if (this.options.preventMouseDownDefault) e.preventDefault();\n    if (this.options.stopMouseDownPropagation) e.stopPropagation();\n\n    /**\n     * @type {boolean} Whether the mouse is being held onKeyPress\n     */\n    this.isMouseHold = true;\n\n    if (this.holdInteractionTimeout) clearTimeout(this.holdInteractionTimeout);\n\n    if (this.holdTimeout) clearTimeout(this.holdTimeout);\n\n    /**\n     * @type {object} Time to wait until a key hold is detected\n     */\n    if (!this.options.disableButtonHold) {\n      this.holdTimeout = setTimeout(() => {\n        if (\n          this.isMouseHold &&\n          ((!button.includes(\"{\") && !button.includes(\"}\")) ||\n            button === \"{delete}\" ||\n            button === \"{backspace}\" ||\n            button === \"{bksp}\" ||\n            button === \"{space}\" ||\n            button === \"{tab}\")\n        ) {\n          if (this.options.debug) console.log(\"Button held:\", button);\n\n          this.handleButtonHold(button, e);\n        }\n        clearTimeout(this.holdTimeout);\n      }, 500);\n    }\n  }\n\n  /**\n   * Handles button mouseup\n   */\n  handleButtonMouseUp(button) {\n    this.isMouseHold = false;\n    if (this.holdInteractionTimeout) clearTimeout(this.holdInteractionTimeout);\n\n    /**\n     * Calling onKeyReleased\n     */\n    if (button && typeof this.options.onKeyReleased === \"function\")\n      this.options.onKeyReleased(button);\n  }\n\n  /**\n   * Handles container mousedown\n   */\n  handleKeyboardContainerMouseDown(e) {\n    /**\n     * Handle event options\n     */\n    if (this.options.preventMouseDownDefault) e.preventDefault();\n  }\n\n  /**\n   * Handles button hold\n   */\n  /* istanbul ignore next */\n  handleButtonHold(button) {\n    if (this.holdInteractionTimeout) clearTimeout(this.holdInteractionTimeout);\n\n    /**\n     * @type {object} Timeout dictating the speed of key hold iterations\n     */\n    this.holdInteractionTimeout = setTimeout(() => {\n      if (this.isMouseHold) {\n        this.handleButtonClicked(button);\n        this.handleButtonHold(button);\n      } else {\n        clearTimeout(this.holdInteractionTimeout);\n      }\n    }, 100);\n  }\n\n  /**\n   * Send a command to all simple-keyboard instances (if you have several instances).\n   */\n  syncInstanceInputs() {\n    this.dispatch(instance => {\n      instance.replaceInput(this.input);\n      instance.caretPosition = this.caretPosition;\n    });\n  }\n\n  /**\n   * Clear the keyboard’s input.\n   * @param {string} [inputName] optional - the internal input to select\n   */\n  clearInput(inputName) {\n    inputName = inputName || this.options.inputName;\n    this.input[inputName] = \"\";\n\n    /**\n     * Reset caretPosition\n     */\n    this.caretPosition = 0;\n\n    /**\n     * Enforce syncInstanceInputs, if set\n     */\n    if (this.options.syncInstanceInputs) this.syncInstanceInputs();\n  }\n\n  /**\n   * Get the keyboard’s input (You can also get it from the onChange prop).\n   * @param  {string} [inputName] optional - the internal input to select\n   */\n  getInput(inputName) {\n    inputName = inputName || this.options.inputName;\n\n    /**\n     * Enforce syncInstanceInputs, if set\n     */\n    if (this.options.syncInstanceInputs) this.syncInstanceInputs();\n\n    return this.input[inputName];\n  }\n\n  /**\n   * Set the keyboard’s input.\n   * @param  {string} input the input value\n   * @param  {string} inputName optional - the internal input to select\n   */\n  setInput(input, inputName) {\n    inputName = inputName || this.options.inputName;\n    this.input[inputName] = input;\n\n    /**\n     * Enforce syncInstanceInputs, if set\n     */\n    if (this.options.syncInstanceInputs) this.syncInstanceInputs();\n  }\n\n  /**\n   * Replace the input object (`keyboard.input`)\n   * @param  {object} inputObj The input object\n   */\n  replaceInput(inputObj) {\n    this.input = inputObj;\n  }\n\n  /**\n   * Set new option or modify existing ones after initialization.\n   * @param  {object} options The options to set\n   */\n  setOptions(options) {\n    options = options || {};\n    this.options = Object.assign(this.options, options);\n\n    /**\n     * Some option changes require adjustments before re-render\n     */\n    this.onSetOptions(options);\n\n    /**\n     * Rendering\n     */\n    this.render();\n  }\n\n  /**\n   * Executing actions depending on changed options\n   * @param  {object} options The options to set\n   */\n  onSetOptions(options) {\n    if (options.inputName) {\n      /**\n       * inputName changed. This requires a caretPosition reset\n       */\n      if (this.options.debug) {\n        console.log(\"inputName changed. caretPosition reset.\");\n      }\n\n      this.caretPosition = null;\n    }\n  }\n\n  /**\n   * Remove all keyboard rows and reset keyboard values.\n   * Used interally between re-renders.\n   */\n  clear() {\n    this.keyboardDOM.innerHTML = \"\";\n    this.keyboardDOM.className = this.keyboardDOMClass;\n    this.buttonElements = {};\n  }\n\n  /**\n   * Send a command to all simple-keyboard instances at once (if you have multiple instances).\n   * @param  {function(instance: object, key: string)} callback Function to run on every instance\n   */\n  dispatch(callback) {\n    if (!window[\"SimpleKeyboardInstances\"]) {\n      console.warn(\n        `SimpleKeyboardInstances is not defined. Dispatch cannot be called.`\n      );\n      throw new Error(\"INSTANCES_VAR_ERROR\");\n    }\n\n    return Object.keys(window[\"SimpleKeyboardInstances\"]).forEach(key => {\n      callback(window[\"SimpleKeyboardInstances\"][key], key);\n    });\n  }\n\n  /**\n   * Adds/Modifies an entry to the `buttonTheme`. Basically a way to add a class to a button.\n   * @param  {string} buttons List of buttons to select (separated by a space).\n   * @param  {string} className Classes to give to the selected buttons (separated by space).\n   */\n  addButtonTheme(buttons, className) {\n    if (!className || !buttons) return false;\n\n    buttons.split(\" \").forEach(button => {\n      className.split(\" \").forEach(classNameItem => {\n        if (!this.options.buttonTheme) this.options.buttonTheme = [];\n\n        let classNameFound = false;\n\n        /**\n         * If class is already defined, we add button to class definition\n         */\n        this.options.buttonTheme.map(buttonTheme => {\n          if (buttonTheme.class.split(\" \").includes(classNameItem)) {\n            classNameFound = true;\n\n            let buttonThemeArray = buttonTheme.buttons.split(\" \");\n            if (!buttonThemeArray.includes(button)) {\n              classNameFound = true;\n              buttonThemeArray.push(button);\n              buttonTheme.buttons = buttonThemeArray.join(\" \");\n            }\n          }\n          return buttonTheme;\n        });\n\n        /**\n         * If class is not defined, we create a new entry\n         */\n        if (!classNameFound) {\n          this.options.buttonTheme.push({\n            class: classNameItem,\n            buttons: buttons\n          });\n        }\n      });\n    });\n\n    this.render();\n  }\n\n  /**\n   * Removes/Amends an entry to the `buttonTheme`. Basically a way to remove a class previously added to a button through buttonTheme or addButtonTheme.\n   * @param  {string} buttons List of buttons to select (separated by a space).\n   * @param  {string} className Classes to give to the selected buttons (separated by space).\n   */\n  removeButtonTheme(buttons, className) {\n    /**\n     * When called with empty parameters, remove all button themes\n     */\n    if (!buttons && !className) {\n      this.options.buttonTheme = [];\n      this.render();\n      return false;\n    }\n\n    /**\n     * If buttons are passed and buttonTheme has items\n     */\n    if (\n      buttons &&\n      Array.isArray(this.options.buttonTheme) &&\n      this.options.buttonTheme.length\n    ) {\n      let buttonArray = buttons.split(\" \");\n      buttonArray.forEach((button, key) => {\n        this.options.buttonTheme.map((buttonTheme, index) => {\n          /**\n           * If className is set, we affect the buttons only for that class\n           * Otherwise, we afect all classes\n           */\n          if (\n            (className && className.includes(buttonTheme.class)) ||\n            !className\n          ) {\n            let filteredButtonArray = buttonTheme.buttons\n              .split(\" \")\n              .filter(item => item !== button);\n\n            /**\n             * If buttons left, return them, otherwise, remove button Theme\n             */\n            if (filteredButtonArray.length) {\n              buttonTheme.buttons = filteredButtonArray.join(\" \");\n            } else {\n              this.options.buttonTheme.splice(index, 1);\n              buttonTheme = null;\n            }\n          }\n\n          return buttonTheme;\n        });\n      });\n\n      this.render();\n    }\n  }\n\n  /**\n   * Get the DOM Element of a button. If there are several buttons with the same name, an array of the DOM Elements is returned.\n   * @param  {string} button The button layout name to select\n   */\n  getButtonElement(button) {\n    let output;\n\n    let buttonArr = this.buttonElements[button];\n    if (buttonArr) {\n      if (buttonArr.length > 1) {\n        output = buttonArr;\n      } else {\n        output = buttonArr[0];\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * This handles the \"inputPattern\" option\n   * by checking if the provided inputPattern passes\n   */\n  inputPatternIsValid(inputVal) {\n    let inputPatternRaw = this.options.inputPattern;\n    let inputPattern;\n\n    /**\n     * Check if input pattern is global or targeted to individual inputs\n     */\n    if (inputPatternRaw instanceof RegExp) {\n      inputPattern = inputPatternRaw;\n    } else {\n      inputPattern = inputPatternRaw[this.options.inputName];\n    }\n\n    if (inputPattern && inputVal) {\n      let didInputMatch = inputPattern.test(inputVal);\n\n      if (this.options.debug) {\n        console.log(\n          `inputPattern (\"${inputPattern}\"): ${\n            didInputMatch ? \"passed\" : \"did not pass!\"\n          }`\n        );\n      }\n\n      return didInputMatch;\n    } else {\n      /**\n       * inputPattern doesn't seem to be set for the current input, or input is empty. Pass.\n       */\n      return true;\n    }\n  }\n\n  /**\n   * Handles simple-keyboard event listeners\n   */\n  setEventListeners() {\n    /**\n     * Only first instance should set the event listeners\n     */\n    if (this.isFirstKeyboardInstance || !this.allKeyboardInstances) {\n      if (this.options.debug) {\n        console.log(`Caret handling started (${this.keyboardDOMClass})`);\n      }\n\n      /**\n       * Event Listeners\n       */\n      document.addEventListener(\"keyup\", this.handleKeyUp);\n      document.addEventListener(\"keydown\", this.handleKeyDown);\n      document.addEventListener(\"mouseup\", this.handleMouseUp);\n      document.addEventListener(\"touchend\", this.handleTouchEnd);\n    }\n  }\n\n  /**\n   * Event Handler: KeyUp\n   */\n  handleKeyUp(event) {\n    this.caretEventHandler(event);\n\n    if (this.options.physicalKeyboardHighlight) {\n      this.physicalKeyboard.handleHighlightKeyUp(event);\n    }\n  }\n\n  /**\n   * Event Handler: KeyDown\n   */\n  handleKeyDown(event) {\n    if (this.options.physicalKeyboardHighlight) {\n      this.physicalKeyboard.handleHighlightKeyDown(event);\n    }\n  }\n\n  /**\n   * Event Handler: MouseUp\n   */\n  handleMouseUp(event) {\n    this.caretEventHandler(event);\n  }\n\n  /**\n   * Event Handler: TouchEnd\n   */\n  handleTouchEnd(event) {\n    this.caretEventHandler(event);\n  }\n\n  /**\n   * Called by {@link setEventListeners} when an event that warrants a cursor position update is triggered\n   */\n  caretEventHandler(event) {\n    let targetTagName;\n    if (event.target.tagName) {\n      targetTagName = event.target.tagName.toLowerCase();\n    }\n\n    this.dispatch(instance => {\n      if (instance.isMouseHold) {\n        instance.isMouseHold = false;\n      }\n\n      if (\n        (targetTagName === \"textarea\" || targetTagName === \"input\") &&\n        !instance.options.disableCaretPositioning\n      ) {\n        /**\n         * Tracks current cursor position\n         * As keys are pressed, text will be added/removed at that position within the input.\n         */\n        instance.caretPosition = event.target.selectionStart;\n\n        if (instance.options.debug) {\n          console.log(\n            \"Caret at: \",\n            event.target.selectionStart,\n            event.target.tagName.toLowerCase(),\n            `(${instance.keyboardDOMClass})`\n          );\n        }\n      } else if (instance.options.disableCaretPositioning) {\n        /**\n         * If we toggled off disableCaretPositioning, we must ensure caretPosition doesn't persist once reactivated.\n         */\n        instance.caretPosition = null;\n      }\n    });\n  }\n\n  /**\n   * Destroy keyboard listeners and DOM elements\n   */\n  destroy() {\n    /**\n     * Remove listeners\n     */\n    document.removeEventListener(\"keyup\", this.handleKeyUp);\n    document.removeEventListener(\"keydown\", this.handleKeyDown);\n    document.removeEventListener(\"mouseup\", this.handleMouseUp);\n    document.removeEventListener(\"touchend\", this.handleTouchEnd);\n\n    /**\n     * Clear DOM\n     */\n    this.clear();\n  }\n\n  /**\n   * Process buttonTheme option\n   */\n  getButtonThemeClasses(button) {\n    let buttonTheme = this.options.buttonTheme;\n    let buttonClasses = [];\n\n    if (Array.isArray(buttonTheme)) {\n      buttonTheme.forEach(themeObj => {\n        if (\n          themeObj.class &&\n          typeof themeObj.class === \"string\" &&\n          (themeObj.buttons && typeof themeObj.buttons === \"string\")\n        ) {\n          let themeObjClasses = themeObj.class.split(\" \");\n          let themeObjButtons = themeObj.buttons.split(\" \");\n\n          if (themeObjButtons.includes(button)) {\n            buttonClasses = [...buttonClasses, ...themeObjClasses];\n          }\n        } else {\n          console.warn(\n            `Incorrect \"buttonTheme\". Please check the documentation.`,\n            themeObj\n          );\n        }\n      });\n    }\n\n    return buttonClasses;\n  }\n\n  /**\n   * Process buttonAttributes option\n   */\n  setDOMButtonAttributes(button, callback) {\n    let buttonAttributes = this.options.buttonAttributes;\n\n    if (Array.isArray(buttonAttributes)) {\n      buttonAttributes.forEach(attrObj => {\n        if (\n          attrObj.attribute &&\n          typeof attrObj.attribute === \"string\" &&\n          (attrObj.value && typeof attrObj.value === \"string\") &&\n          (attrObj.buttons && typeof attrObj.buttons === \"string\")\n        ) {\n          let attrObjButtons = attrObj.buttons.split(\" \");\n\n          if (attrObjButtons.includes(button)) {\n            callback(attrObj.attribute, attrObj.value);\n          }\n        } else {\n          console.warn(\n            `Incorrect \"buttonAttributes\". Please check the documentation.`,\n            attrObj\n          );\n        }\n      });\n    }\n  }\n\n  onTouchDeviceDetected() {\n    /**\n     * Processing autoTouchEvents\n     */\n    this.processAutoTouchEvents();\n\n    /**\n     * Disabling contextual window on touch devices\n     */\n    this.disableContextualWindow();\n  }\n\n  /**\n   * Disabling contextual window for hg-button\n   */\n  /* istanbul ignore next */\n  disableContextualWindow() {\n    window.oncontextmenu = event => {\n      if (event.target.classList.contains(\"hg-button\")) {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n      }\n    };\n  }\n\n  /**\n   * Process autoTouchEvents option\n   */\n  processAutoTouchEvents() {\n    if (this.options.autoUseTouchEvents) {\n      this.options.useTouchEvents = true;\n\n      if (this.options.debug) {\n        console.log(\n          `autoUseTouchEvents: Touch device detected, useTouchEvents enabled.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Executes the callback function once simple-keyboard is rendered for the first time (on initialization).\n   */\n  onInit() {\n    if (this.options.debug) {\n      console.log(`${this.keyboardDOMClass} Initialized`);\n    }\n\n    /**\n     * setEventListeners\n     */\n    this.setEventListeners();\n\n    if (typeof this.options.onInit === \"function\") this.options.onInit();\n  }\n\n  /**\n   * Executes the callback function before a simple-keyboard render.\n   */\n  beforeFirstRender() {\n    /**\n     * Performing actions when touch device detected\n     */\n    if (this.utilities.isTouchDevice()) {\n      this.onTouchDeviceDetected();\n    }\n\n    if (typeof this.options.beforeFirstRender === \"function\")\n      this.options.beforeFirstRender();\n\n    /**\n     * Notify about PointerEvents usage\n     */\n    if (\n      this.isFirstKeyboardInstance &&\n      this.utilities.pointerEventsSupported() &&\n      !this.options.useTouchEvents &&\n      !this.options.useMouseEvents\n    ) {\n      if (this.options.debug) {\n        console.log(\"Using PointerEvents as it is supported by this browser\");\n      }\n    }\n\n    /**\n     * Notify about touch events usage\n     */\n    if (this.options.useTouchEvents) {\n      if (this.options.debug) {\n        console.log(\n          \"useTouchEvents has been enabled. Only touch events will be used.\"\n        );\n      }\n    }\n  }\n\n  /**\n   * Executes the callback function before a simple-keyboard render.\n   */\n  beforeRender() {\n    if (typeof this.options.beforeRender === \"function\")\n      this.options.beforeRender();\n  }\n\n  /**\n   * Executes the callback function every time simple-keyboard is rendered (e.g: when you change layouts).\n   */\n  onRender() {\n    if (typeof this.options.onRender === \"function\") this.options.onRender();\n  }\n\n  /**\n   * Executes the callback function once all modules have been loaded\n   */\n  onModulesLoaded() {\n    if (typeof this.options.onModulesLoaded === \"function\")\n      this.options.onModulesLoaded();\n  }\n\n  /**\n   * Register module\n   */\n  registerModule = (name, initCallback) => {\n    if (!this.modules[name]) this.modules[name] = {};\n\n    initCallback(this.modules[name]);\n  };\n\n  /**\n   * Load modules\n   */\n  loadModules() {\n    if (Array.isArray(this.options.modules)) {\n      this.options.modules.forEach(Module => {\n        let module = new Module();\n\n        /* istanbul ignore next */\n        if (module.constructor.name && module.constructor.name !== \"Function\") {\n          let classStr = `module-${this.utilities.camelCase(\n            module.constructor.name\n          )}`;\n          this.keyboardPluginClasses =\n            this.keyboardPluginClasses + ` ${classStr}`;\n        }\n\n        module.init(this);\n      });\n\n      this.keyboardPluginClasses =\n        this.keyboardPluginClasses + \" modules-loaded\";\n\n      this.render();\n      this.onModulesLoaded();\n    }\n  }\n\n  /**\n   * Get module prop\n   */\n  getModuleProp(name, prop) {\n    if (!this.modules[name]) return false;\n\n    return this.modules[name][prop];\n  }\n\n  /**\n   * getModulesList\n   */\n  getModulesList() {\n    return Object.keys(this.modules);\n  }\n\n  /**\n   * Parse Row DOM containers\n   */\n  parseRowDOMContainers(\n    rowDOM,\n    rowIndex,\n    containerStartIndexes,\n    containerEndIndexes\n  ) {\n    let rowDOMArray = Array.from(rowDOM.children);\n    let removedElements = 0;\n\n    if (rowDOMArray.length) {\n      containerStartIndexes.forEach((startIndex, arrIndex) => {\n        let endIndex = containerEndIndexes[arrIndex];\n\n        /**\n         * If there exists a respective end index\n         * if end index comes after start index\n         */\n        if (!endIndex || !(endIndex > startIndex)) {\n          return false;\n        }\n\n        /**\n         * Updated startIndex, endIndex\n         * This is since the removal of buttons to place a single button container\n         * results in a modified array size\n         */\n        let updated_startIndex = startIndex - removedElements;\n        let updated_endIndex = endIndex - removedElements;\n\n        /**\n         * Create button container\n         */\n        let containerDOM = document.createElement(\"div\");\n        containerDOM.className += \"hg-button-container\";\n        let containerUID = `${this.options.layoutName}-r${rowIndex}c${arrIndex}`;\n        containerDOM.setAttribute(\"data-skUID\", containerUID);\n\n        /**\n         * Taking elements due to be inserted into container\n         */\n        let containedElements = rowDOMArray.splice(\n          updated_startIndex,\n          updated_endIndex - updated_startIndex + 1\n        );\n        removedElements = updated_endIndex - updated_startIndex;\n\n        /**\n         * Inserting elements to container\n         */\n        containedElements.forEach(element => containerDOM.appendChild(element));\n\n        /**\n         * Adding container at correct position within rowDOMArray\n         */\n        rowDOMArray.splice(updated_startIndex, 0, containerDOM);\n\n        /**\n         * Clearing old rowDOM children structure\n         */\n        rowDOM.innerHTML = \"\";\n\n        /**\n         * Appending rowDOM new children list\n         */\n        rowDOMArray.forEach(element => rowDOM.appendChild(element));\n\n        if (this.options.debug) {\n          console.log(\n            \"rowDOMContainer\",\n            containedElements,\n            updated_startIndex,\n            updated_endIndex,\n            removedElements + 1\n          );\n        }\n      });\n    }\n\n    return rowDOM;\n  }\n\n  /**\n   * Renders rows and buttons as per options\n   */\n  render() {\n    /**\n     * Clear keyboard\n     */\n    this.clear();\n\n    /**\n     * Calling beforeFirstRender\n     */\n    if (!this.initialized) {\n      this.beforeFirstRender();\n    }\n\n    /**\n     * Calling beforeRender\n     */\n    this.beforeRender();\n\n    let layoutClass = `hg-layout-${this.options.layoutName}`;\n    let layout = this.options.layout || KeyboardLayout.getDefaultLayout();\n    let useTouchEvents = this.options.useTouchEvents || false;\n    let useTouchEventsClass = useTouchEvents ? \"hg-touch-events\" : \"\";\n    let useMouseEvents = this.options.useMouseEvents || false;\n    let disableRowButtonContainers = this.options.disableRowButtonContainers;\n\n    /**\n     * Adding themeClass, layoutClass to keyboardDOM\n     */\n    this.keyboardDOM.className += ` ${this.options.theme} ${layoutClass} ${this.keyboardPluginClasses} ${useTouchEventsClass}`;\n\n    /**\n     * Iterating through each row\n     */\n    layout[this.options.layoutName].forEach((row, rIndex) => {\n      let rowArray = row.split(\" \");\n\n      /**\n       * Creating empty row\n       */\n      let rowDOM = document.createElement(\"div\");\n      rowDOM.className += \"hg-row\";\n\n      /**\n       * Tracking container indicators in rows\n       */\n      let containerStartIndexes = [];\n      let containerEndIndexes = [];\n\n      /**\n       * Iterating through each button in row\n       */\n      rowArray.forEach((button, bIndex) => {\n        /**\n         * Check if button has a container indicator\n         */\n        let buttonHasContainerStart =\n          !disableRowButtonContainers &&\n          button.includes(\"[\") &&\n          button.length > 1;\n        let buttonHasContainerEnd =\n          !disableRowButtonContainers &&\n          button.includes(\"]\") &&\n          button.length > 1;\n\n        /**\n         * Save container start index, if applicable\n         */\n        if (buttonHasContainerStart) {\n          containerStartIndexes.push(bIndex);\n\n          /**\n           * Removing indicator\n           */\n          button = button.replace(/\\[/g, \"\");\n        }\n\n        if (buttonHasContainerEnd) {\n          containerEndIndexes.push(bIndex);\n\n          /**\n           * Removing indicator\n           */\n          button = button.replace(/\\]/g, \"\");\n        }\n\n        /**\n         * Processing button options\n         */\n        let fctBtnClass = this.utilities.getButtonClass(button);\n        let buttonDisplayName = this.utilities.getButtonDisplayName(\n          button,\n          this.options.display,\n          this.options.mergeDisplay\n        );\n\n        /**\n         * Creating button\n         */\n        let buttonType = this.options.useButtonTag ? \"button\" : \"div\";\n        let buttonDOM = document.createElement(buttonType);\n        buttonDOM.className += `hg-button ${fctBtnClass}`;\n\n        /**\n         * Adding buttonTheme\n         */\n        buttonDOM.classList.add(...this.getButtonThemeClasses(button));\n\n        /**\n         * Adding buttonAttributes\n         */\n        this.setDOMButtonAttributes(button, (attribute, value) => {\n          buttonDOM.setAttribute(attribute, value);\n        });\n\n        /**\n         * Handle button click event\n         */\n        /* istanbul ignore next */\n        if (\n          this.utilities.pointerEventsSupported() &&\n          !useTouchEvents &&\n          !useMouseEvents\n        ) {\n          /**\n           * Handle PointerEvents\n           */\n          buttonDOM.onpointerdown = e => {\n            this.handleButtonClicked(button);\n            this.handleButtonMouseDown(button, e);\n          };\n          buttonDOM.onpointerup = () => this.handleButtonMouseUp(button);\n          buttonDOM.onpointercancel = () => this.handleButtonMouseUp(button);\n        } else {\n          /**\n           * Fallback for browsers not supporting PointerEvents\n           */\n          if (useTouchEvents) {\n            /**\n             * Handle touch events\n             */\n            buttonDOM.ontouchstart = e => {\n              this.handleButtonClicked(button);\n              this.handleButtonMouseDown(button, e);\n            };\n            buttonDOM.ontouchend = () => this.handleButtonMouseUp(button);\n            buttonDOM.ontouchcancel = () => this.handleButtonMouseUp(button);\n          } else {\n            /**\n             * Handle mouse events\n             */\n            buttonDOM.onclick = () => {\n              this.isMouseHold = false;\n              this.handleButtonClicked(button);\n            };\n            buttonDOM.onmousedown = e => this.handleButtonMouseDown(button, e);\n            buttonDOM.onmouseup = () => this.handleButtonMouseUp(button);\n          }\n        }\n\n        /**\n         * Adding identifier\n         */\n        buttonDOM.setAttribute(\"data-skBtn\", button);\n\n        /**\n         * Adding unique id\n         * Since there's no limit on spawning same buttons, the unique id ensures you can style every button\n         */\n        let buttonUID = `${this.options.layoutName}-r${rIndex}b${bIndex}`;\n        buttonDOM.setAttribute(\"data-skBtnUID\", buttonUID);\n\n        /**\n         * Adding button label to button\n         */\n        let buttonSpanDOM = document.createElement(\"span\");\n        buttonSpanDOM.innerHTML = buttonDisplayName;\n        buttonDOM.appendChild(buttonSpanDOM);\n\n        /**\n         * Adding to buttonElements\n         */\n        if (!this.buttonElements[button]) this.buttonElements[button] = [];\n\n        this.buttonElements[button].push(buttonDOM);\n\n        /**\n         * Appending button to row\n         */\n        rowDOM.appendChild(buttonDOM);\n      });\n\n      /**\n       * Parse containers in row\n       */\n      rowDOM = this.parseRowDOMContainers(\n        rowDOM,\n        rIndex,\n        containerStartIndexes,\n        containerEndIndexes\n      );\n\n      /**\n       * Appending row to keyboard\n       */\n      this.keyboardDOM.appendChild(rowDOM);\n    });\n\n    /**\n     * Calling onRender\n     */\n    this.onRender();\n\n    if (!this.initialized) {\n      /**\n       * Ensures that onInit and beforeFirstRender are only called once per instantiation\n       */\n      this.initialized = true;\n\n      /**\n       * Handling parent events\n       */\n      /* istanbul ignore next */\n      if (\n        this.utilities.pointerEventsSupported() &&\n        !useTouchEvents &&\n        !useMouseEvents\n      ) {\n        document.onpointerup = () => this.handleButtonMouseUp();\n        this.keyboardDOM.onpointerdown = e =>\n          this.handleKeyboardContainerMouseDown(e);\n      } else if (useTouchEvents) {\n        /**\n         * Handling ontouchend, ontouchcancel\n         */\n        document.ontouchend = () => this.handleButtonMouseUp();\n        document.ontouchcancel = () => this.handleButtonMouseUp();\n\n        this.keyboardDOM.ontouchstart = e =>\n          this.handleKeyboardContainerMouseDown(e);\n      } else if (!useTouchEvents) {\n        /**\n         * Handling mouseup\n         */\n        document.onmouseup = () => this.handleButtonMouseUp();\n        this.keyboardDOM.onmousedown = e =>\n          this.handleKeyboardContainerMouseDown(e);\n      }\n\n      /**\n       * Calling onInit\n       */\n      this.onInit();\n    }\n  }\n}\n\nexport default SimpleKeyboard;\n","import SimpleKeyboard from \"./components/Keyboard\";\nexport default SimpleKeyboard;\n"],"sourceRoot":""}